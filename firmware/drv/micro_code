#define MICRO_CODE_NUM   8
#define NAND_ERASE_PTR   6'd1
#define NAND_WRITE_PTR   6'd2
#define NAND_READ_PTR    6'd3

//instruction
#define INST_WRITE 0x0000
#define INST_MOVE  0x8000
#define INST_JUMP  0xC000
  #define JUMP_EQFW  0x10
  #define JUMP_EQBK  0x11
  #define JUMP_NEBK  0x15
  #define JUMP_NCFW  0x18
  #define JUMP_NCBK  0x19
#define INST_SHIFT 0xE000
  #define SHIFT_RL4  0x14 //REG_P0 << 4
#define INST_OPRT  0xF000
  #define OPRT_ADD   0x01
  #define OPRT_AND   0x04
#define INST_NOP   0xFFFF
#define INST_FIN   0xFFFE

//register address
#define NAND_READ  0x00
#define NAND_WRITE 0x04
#define NAND_RDMA  0x08
#define NAND_WDMA  0x0C
#define NAND_CMD   0x10
#define NAND_ADR   0x14
#define NAND_CEN   0x18
#define NAND_WAIT  0x1C

#define PROC_REG0  0x20
#define PROC_REG1  0x21

#define ECTI_STS   0x48
  #define RCAH_SET   0x01
  #define AIPR_SET   0x04
#define CEN_NUM    0x4C
#define SINGLE_PL  0x4E
#define COL_ADR1   0x52
#define COL_ADR2   0x53
#define ROW_ADR1   0x54
#define ROW_ADR2   0x55
#define ROW_ADR3   0x56
#define ROW_ADR4   0x57
#define NAND_RDT   0x58
#define SET_BUSY   0x60
#ifdef RCAH_EN
  #define RCMD_RSTS  0x40
#else
  #define RCMD_RSTS  0x00
#endif
  #define AIPR_RSTS  0x20 //bit5: aipr type
  #define ERAS_RSTS  0x11 //bit4: force read status
  #define PROG_RSTS  0x12
  #define PMED_RSTS  0x13
#define STS_DATA   0x61
#define SET_PLANE  0x62
  #define AUTO_PL    0x10
#define DMA_STS    0x64
#define OSPG_NUM   0x6C
#define LOWDQS_EN  0x7A
#define AIPR_STS   0x7F

//NAND command
#define READ_PAGE  0x00
#define READ_MTPL  0x32
#define READ_END   0x30
#define RCAH_CMD   0x31
#define RCAH_END   0x3F
#ifdef NAND_BICS5
#define RCOL_CMD   0x05
#else
#define RCOL_CMD   0x06
#endif
#define RCOL_END   0xE0

#define PROG_CMD   0x80
#define PROG_MTPL  0x11
#define PROG_END   0x10
#define PROG_MED   0x1A //for Kioxia/YMTC NAND only

#define ERAS_CMD   0x60
#define ERAS_MTPL  0xD1 //for Micron NAND only
#define ERAS_END   0xD0

#define READ_STS   0x70
#define READ_ASTS  0x77
#define READ_ESTS  0x78
  #define STS_ARDY   0x60 //bit5: array ready, bit[6]: register ready
#ifdef RCAH_EN
  #define STS_RDY    0x40
#else
  #define STS_RDY    0x60
#endif

#define AIPR_ENTR   0x0B
#define AIPR_EXIT   0x0C

//wait timer
#ifdef NAND_2400M //use X3-9070 timing
  #define WAIT_TWB     59  //wait tWB(100ns)
  #define WAIT_TADL    179 //wait tADL(300ns)
  #define WAIT_TCCS    179 //wait tCCS(300ns)
#elif defined(NAND_1600M) //use B47R timing
  #define WAIT_TWB     39  //wait tWB(B58R:80ns, B47R:100ns)
  #define WAIT_TADL    59  //wait tADL(150ns)
  #define WAIT_TCCS    159 //wait tCCS(B58R:275ns, B47R:400ns)
#else //FPGA mode, NAND_500M, use B47R timing
  #define WAIT_TWB     10  //wait tWB(B58R:80ns, B47R:100ns)
  #define WAIT_TADL    15  //wait tADL(150ns)
  #define WAIT_TCCS    39  //wait tCCS(B58R:275ns, B47R:400ns)
#endif

//jump number
#ifdef DMY_READ
  #define JUMP_DRD 2
#else
  #define JUMP_DRD 0
#endif
#ifdef PROC_TDLY
  #define JUMP_ADD JUMP_DRD+1
#else
  #define JUMP_ADD JUMP_DRD+0
#endif


//other
#define CEN_OFF    0x80
//#define WAIT_TRPH    8
#define PLANE_END  (  PLANE_QNTY -   1)
#define OSPG_END     3


const word gw_micro_code[][64] = {
//wire [0:64*16-1] micro_code [MICRO_CODE_NUM];

//read status command, cmd_ptr = 6'd0
//assign micro_code[0] =
{
(INST_MOVE  | (CEN_NUM   << 7) | NAND_CEN ), //enable CEn
(INST_WRITE | (READ_STS  << 7) | NAND_CMD ), //send read status cmd(0x70) to NAND
#ifdef RSTS_LDQS
(INST_WRITE | (0x1       << 7) | LOWDQS_EN), //enable low dqs mode
#endif
#ifdef DMY_READ
(INST_WRITE | (0x1       << 7) | NAND_READ), //dummy read
(INST_WRITE | (10        << 7) | NAND_WAIT), //need wait 10 cycle
#endif
(INST_WRITE | (0x0       << 7) | NAND_READ), //read status
#ifdef PROC_TDLY
(INST_MOVE  | (NAND_RDT  << 7) | PROC_REG0), //dummy read for FPGA timing issue
#endif
(INST_MOVE  | (NAND_RDT  << 7) | STS_DATA ), //move NAND read data to status check reg
#ifdef RSTS_LDQS
(INST_WRITE | (0x0       << 7) | LOWDQS_EN), //disable low dqs mode
#endif
#ifndef NAND_B47R
(INST_WRITE | (CEN_OFF   << 7) | NAND_CEN ), //disable CEn
//(INST_WRITE | (WAIT_TRPH << 7) | NAND_WAIT), //need wait tRPSTH(15/25ns)
#endif
(INST_FIN                                   )  //finish
},

//multi-plane erase command, cmd_ptr = 6'd1
//assign micro_code[1] =
{
(INST_MOVE  | (CEN_NUM   << 7) | NAND_CEN ), //enable CEn
(INST_WRITE | (0x0       << 7) | SET_PLANE), //init plane number
(INST_MOVE  | (AIPR_STS  << 7) | PROC_REG0), //copy "aipr status" to processor reg0
(INST_WRITE | (0x0       << 7) | PROC_REG1), //set "0x0" to processor reg1
(INST_JUMP  | (JUMP_EQFW << 8) |   7      ), //compare aipr status, if aipr no set, jump to "erase cmd"
(INST_WRITE | (READ_ESTS << 7) | NAND_CMD ), //send read enhance status cmd(0x78) to NAND
(INST_MOVE  | (ROW_ADR1  << 7) | NAND_ADR ), //send row adr1 to NAND
(INST_MOVE  | (ROW_ADR2  << 7) | NAND_ADR ), //send row adr2 to NAND
(INST_MOVE  | (ROW_ADR3  << 7) | NAND_ADR ), //send row adr3 to NAND
(INST_MOVE  | (ROW_ADR4  << 7) | NAND_ADR ), //send row adr4 to NAND
(INST_WRITE | (AIPR_EXIT << 7) | NAND_CMD ), //send aipr disable cmd(0x0C) to NAND
#ifdef B47R_SLC
(INST_WRITE | (0x3B      << 7) | NAND_CMD ), //send SLC mode cmd(0x3B) to NAND
#endif
(INST_WRITE | (ERAS_CMD  << 7) | NAND_CMD ), //send erase cmd(0x60) to NAND
(INST_MOVE  | (ROW_ADR1  << 7) | NAND_ADR ), //send row adr1 to NAND
(INST_MOVE  | (ROW_ADR2  << 7) | NAND_ADR ), //send row adr2 to NAND
(INST_MOVE  | (ROW_ADR3  << 7) | NAND_ADR ), //send row adr3 to NAND
#ifndef NAND_BICS5
(INST_MOVE  | (ROW_ADR4  << 7) | NAND_ADR ), //send row adr4 to NAND
#endif
(INST_MOVE  | (SET_PLANE << 7) | PROC_REG0), //copy "current plane" to processor reg0
(INST_WRITE | (PLANE_END << 7) | PROC_REG1), //set "plane end number" to processor reg1
#ifdef NAND_BICS5
(INST_JUMP  | (JUMP_EQFW << 8) |   3      ), //compare plane number, if plane fin, jump to "erase end cmd"
#else
(INST_JUMP  | (JUMP_EQFW << 8) |   (11+JUMP_ADD)     ), //compare plane number, if plane fin, jump to "erase end cmd"
#endif
(INST_OPRT  | (OPRT_ADD  << 7) | SET_PLANE), //add plane number
#ifdef NAND_BICS5
(INST_JUMP  | (JUMP_NCBK << 8) |   8      ), //jump back to "erase cmd"
#else
(INST_WRITE | (ERAS_MTPL << 7) | NAND_CMD ), //send erase multi-plane cmd(0xD1) to NAND
(INST_WRITE | (WAIT_TWB  << 7) | NAND_WAIT), //need wait tWB(80/90/100ns)
(INST_WRITE | (READ_STS  << 7) | NAND_CMD ), //send read status cmd(0x70) to NAND
#ifdef DMY_READ
(INST_WRITE | (0x1       << 7) | NAND_READ), //dummy read
(INST_WRITE | (10        << 7) | NAND_WAIT), //need wait 10 cycle
#endif
(INST_WRITE | (0x0       << 7) | NAND_READ), //read status
#ifdef PROC_TDLY
(INST_MOVE  | (NAND_RDT  << 7) | PROC_REG0), //dummy read for FPGA timing issue
#endif
(INST_MOVE  | (NAND_RDT  << 7) | PROC_REG0), //copy NAND read data to processor reg0
(INST_WRITE | (STS_ARDY  << 7) | PROC_REG1), //set nand_ready_bitmap(0x60) to processor reg1
(INST_OPRT  | (OPRT_AND  << 7) | PROC_REG0), //sts_data & nand_ready_bitmap(0x60)
(INST_JUMP  | (JUMP_EQBK << 8) |   (16+JUMP_ADD)     ), //check whether NAND ready, if ready, jump back to "erase cmd"
(INST_JUMP  | (JUMP_NCBK << 8) |   (6 +JUMP_ADD)     ), //jump to "read status cmd"
#endif //NAND_BICS5
(INST_WRITE | (ERAS_END  << 7) | NAND_CMD ), //send erase end(0xD0) to NAND
(INST_WRITE | (ERAS_RSTS << 7) | SET_BUSY ), //set nand status as busy and force read status
(INST_FIN                                   )  //finish
},

//multi-plane program command, cmd_ptr = 6'd2
//assign micro_code[2] =
{
(INST_MOVE  | (CEN_NUM   << 7) | NAND_CEN ), //enable CEn
(INST_WRITE | (0x0       << 7) | SET_PLANE), //init plane number
(INST_MOVE  | (AIPR_STS  << 7) | PROC_REG0), //copy "aipr status" to processor reg0
(INST_WRITE | (0x0       << 7) | PROC_REG1), //set "0x0" to processor reg1
(INST_JUMP  | (JUMP_EQFW << 8) |   7      ), //compare aipr status, if aipr no set, jump to "program cmd"
(INST_WRITE | (READ_ESTS << 7) | NAND_CMD ), //send read enhance status cmd(0x78) to NAND
(INST_MOVE  | (ROW_ADR1  << 7) | NAND_ADR ), //send row adr1 to NAND
(INST_MOVE  | (ROW_ADR2  << 7) | NAND_ADR ), //send row adr2 to NAND
(INST_MOVE  | (ROW_ADR3  << 7) | NAND_ADR ), //send row adr3 to NAND
(INST_MOVE  | (ROW_ADR4  << 7) | NAND_ADR ), //send row adr4 to NAND
(INST_WRITE | (AIPR_EXIT << 7) | NAND_CMD ), //send aipr disable cmd(0x0C) to NAND
#ifdef NAND_BICS5
(INST_MOVE  | (OSPG_NUM  << 7) | NAND_CMD ), //send "one shot page number(0x01/0x02/0x03)" to NAND
#endif
#ifdef B47R_SLC
(INST_WRITE | (0x3B      << 7) | NAND_CMD ), //send SLC mode cmd(0x3B) to NAND
#endif
(INST_WRITE | (PROG_CMD  << 7) | NAND_CMD ), //send program cmd(0x80) to NAND
(INST_WRITE | (0x0       << 7) | NAND_ADR ), //send column adr1 to NAND
(INST_WRITE | (0x0       << 7) | NAND_ADR ), //send column adr2 to NAND
(INST_MOVE  | (ROW_ADR1  << 7) | NAND_ADR ), //send row adr1 to NAND
(INST_MOVE  | (ROW_ADR2  << 7) | NAND_ADR ), //send row adr2 to NAND
(INST_MOVE  | (ROW_ADR3  << 7) | NAND_ADR ), //send row adr3 to NAND
#ifndef NAND_BICS5
(INST_MOVE  | (ROW_ADR4  << 7) | NAND_ADR ), //send row adr4 to NAND
#endif
(INST_WRITE | (WAIT_TADL << 7) | NAND_WAIT), //need wait tADL(150/300ns)
(INST_WRITE | (0x0       << 7) | NAND_WDMA), //enable DMA write engine
(INST_MOVE  | (SET_PLANE << 7) | PROC_REG0), //copy "current plane" to processor reg0
(INST_WRITE | (PLANE_END << 7) | PROC_REG1), //set "plane end number" to processor reg1
(INST_JUMP  | (JUMP_EQFW << 8) |   (11+JUMP_ADD)     ), //compare plane number, if plane fin, jump to "program end cmd"
(INST_OPRT  | (OPRT_ADD  << 7) | SET_PLANE), //add plane number
(INST_WRITE | (PROG_MTPL << 7) | NAND_CMD ), //send program multi-plane cmd(0x11) to NAND
(INST_WRITE | (WAIT_TWB  << 7) | NAND_WAIT), //need wait tWB(80/90/100ns)
(INST_WRITE | (READ_STS  << 7) | NAND_CMD ), //send read status cmd(0x70) to NAND
#ifdef DMY_READ
(INST_WRITE | (0x1       << 7) | NAND_READ), //dummy read
(INST_WRITE | (10        << 7) | NAND_WAIT), //need wait 10 cycle
#endif
(INST_WRITE | (0x0       << 7) | NAND_READ), //read status
#ifdef PROC_TDLY
(INST_MOVE  | (NAND_RDT  << 7) | PROC_REG0), //dummy read for FPGA timing issue
#endif
(INST_MOVE  | (NAND_RDT  << 7) | PROC_REG0), //copy NAND read data to processor reg0
(INST_WRITE | (STS_ARDY  << 7) | PROC_REG1), //set nand_ready_bitmap(0x60) to processor reg1
(INST_OPRT  | (OPRT_AND  << 7) | PROC_REG0), //sts_data & nand_ready_bitmap(0x60)
(INST_JUMP  | (JUMP_EQBK << 8) |   (20+JUMP_ADD)     ), //check whether NAND ready, if ready, jump back to "program cmd"
(INST_JUMP  | (JUMP_NCBK << 8) |   (6 +JUMP_ADD)     ), //jump to "read status cmd"
#ifndef NAND_B47R
(INST_MOVE  | (OSPG_NUM  << 7) | PROC_REG0), //copy "one shot page number" to processor reg0
(INST_WRITE | (OSPG_END  << 7) | PROC_REG1), //set "one shot page end(3)" to processor reg1
(INST_JUMP  | (JUMP_EQFW << 8) |   4      ), //compare one shot page number, if is 3, jump to "program end cmd"
(INST_WRITE | (PROG_MED  << 7) | NAND_CMD ), //send program medium(0x1A) to NAND
(INST_WRITE | (PMED_RSTS << 7) | SET_BUSY ), //set nand status as busy and force read status
(INST_JUMP  | (JUMP_NCFW << 8) |   3      ), //jump to "finish"
#endif
(INST_WRITE | (PROG_END  << 7) | NAND_CMD ), //send program end(0x10) to NAND
(INST_WRITE | (PROG_RSTS << 7) | SET_BUSY ), //set nand status as busy and force read status
(INST_FIN                                   )  //finish
},

//multi-plane read command, cmd_ptr = 6'd3
//assign micro_code[3] =
{
(INST_MOVE  | (CEN_NUM   << 7) | NAND_CEN ), //enable CEn
(INST_MOVE  | (SINGLE_PL << 7) | PROC_REG0), //move single_plane to processor reg0
(INST_SHIFT | (SHIFT_RL4 << 7) | SET_PLANE), //init plane number, 0x10:single plane, 0x0:multi-plane
(INST_MOVE  | (AIPR_STS  << 7) | PROC_REG0), //copy "aipr status" to processor reg0
(INST_WRITE | (0x0       << 7) | PROC_REG1), //set "0x0" to processor reg1
(INST_JUMP  | (JUMP_EQFW << 8) |   7      ), //compare aipr status, if aipr no set, jump to "read cmd"
(INST_WRITE | (READ_ESTS << 7) | NAND_CMD ), //send read enhance status cmd(0x78) to NAND
(INST_MOVE  | (ROW_ADR1  << 7) | NAND_ADR ), //send row adr1 to NAND
(INST_MOVE  | (ROW_ADR2  << 7) | NAND_ADR ), //send row adr2 to NAND
(INST_MOVE  | (ROW_ADR3  << 7) | NAND_ADR ), //send row adr3 to NAND
(INST_MOVE  | (ROW_ADR4  << 7) | NAND_ADR ), //send row adr4 to NAND
(INST_WRITE | (AIPR_EXIT << 7) | NAND_CMD ), //send aipr disable cmd(0x0C) to NAND
#ifdef NAND_BICS5
(INST_MOVE  | (OSPG_NUM  << 7) | NAND_CMD ), //send "one shot page number(0x01/0x02/0x03)" to NAND
#endif
#ifdef B47R_SLC
(INST_WRITE | (0x3B      << 7) | NAND_CMD ), //send SLC mode cmd(0x3B) to NAND
#endif
(INST_WRITE | (READ_PAGE << 7) | NAND_CMD ), //send read cmd(0x00) to NAND
(INST_WRITE | (0x0       << 7) | NAND_ADR ), //send column adr1 to NAND
(INST_WRITE | (0x0       << 7) | NAND_ADR ), //send column adr2 to NAND
(INST_MOVE  | (ROW_ADR1  << 7) | NAND_ADR ), //send row adr1 to NAND
(INST_MOVE  | (ROW_ADR2  << 7) | NAND_ADR ), //send row adr2 to NAND
(INST_MOVE  | (ROW_ADR3  << 7) | NAND_ADR ), //send row adr3 to NAND
#ifndef NAND_BICS5
(INST_MOVE  | (ROW_ADR4  << 7) | NAND_ADR ), //send row adr4 to NAND
#endif
(INST_MOVE  | (SET_PLANE << 7) | PROC_REG0), //copy "current plane" to processor reg0
(INST_WRITE | (0x10      << 7) | PROC_REG1), //set 0x10(imply single plane) to processor reg1
(INST_JUMP  | (JUMP_EQFW << 8) |   (13+JUMP_ADD)     ), //compare plane, if single plane, jump to "read end cmd"
(INST_WRITE | (PLANE_END << 7) | PROC_REG1), //set "plane end number" to processor reg1
(INST_JUMP  | (JUMP_EQFW << 8) |   (11+JUMP_ADD)     ), //compare plane number, if plane fin, jump to "read end cmd"
(INST_OPRT  | (OPRT_ADD  << 7) | SET_PLANE), //add plane number
(INST_WRITE | (READ_MTPL << 7) | NAND_CMD ), //send read multi-plane cmd(0x32) to NAND
(INST_WRITE | (WAIT_TWB  << 7) | NAND_WAIT), //need wait tWB(80/90/100ns)
(INST_WRITE | (READ_STS  << 7) | NAND_CMD ), //send read status cmd(0x70) to NAND
#ifdef DMY_READ
(INST_WRITE | (0x1       << 7) | NAND_READ), //dummy read
(INST_WRITE | (10        << 7) | NAND_WAIT), //need wait 10 cycle
#endif
(INST_WRITE | (0x0       << 7) | NAND_READ), //read status
#ifdef PROC_TDLY
(INST_MOVE  | (NAND_RDT  << 7) | PROC_REG0), //dummy read for FPGA timing issue
#endif
(INST_MOVE  | (NAND_RDT  << 7) | PROC_REG0), //copy NAND read data to processor reg0
(INST_WRITE | (STS_RDY   << 7) | PROC_REG1), //set nand_ready_bitmap(0x60) to processor reg1
(INST_OPRT  | (OPRT_AND  << 7) | PROC_REG0), //sts_data & nand_ready_bitmap(0x60)
(INST_JUMP  | (JUMP_EQBK << 8) |   (20+JUMP_ADD)     ), //check whether NAND ready, if ready, jump back to "read cmd"
(INST_JUMP  | (JUMP_NCBK << 8) |   (6 +JUMP_ADD)     ), //jump to "read status cmd"
(INST_MOVE  | (ECTI_STS  << 7) | PROC_REG0), //copy "cache status" to processor reg0
(INST_WRITE | (RCAH_SET  << 7) | PROC_REG1), //set "cache read set" to processor reg1
(INST_JUMP  | (JUMP_EQFW << 8) |   3      ), //compare cache status, if cache read set, jump to "cache read cmd"
(INST_WRITE | (READ_END  << 7) | NAND_CMD ), //send read end(0x30) to NAND
(INST_JUMP  | (JUMP_NCFW << 8) |   2      ), //jump to "set nand status"
(INST_WRITE | (RCAH_CMD  << 7) | NAND_CMD ), //send cache read(0x31) to NAND
(INST_WRITE | (RCMD_RSTS << 7) | SET_BUSY ), //set nand status as busy
(INST_FIN                                   )  //finish
},

//multi-plane read data, cmd_ptr = 6'd4
//assign micro_code[4] =
{
(INST_MOVE  | (CEN_NUM   << 7) | NAND_CEN ), //enable CEn
(INST_WRITE | (AUTO_PL   << 7) | SET_PLANE), //init plane number
(INST_WRITE | (RCOL_CMD  << 7) | NAND_CMD ), //send "change read column cmd(0x05/0x06)" to NAND
(INST_MOVE  | (COL_ADR1  << 7) | NAND_ADR ), //send column adr1 to NAND
(INST_MOVE  | (COL_ADR2  << 7) | NAND_ADR ), //send column adr2 to NAND
(INST_MOVE  | (ROW_ADR1  << 7) | NAND_ADR ), //send row adr1 to NAND
(INST_MOVE  | (ROW_ADR2  << 7) | NAND_ADR ), //send row adr2 to NAND
(INST_MOVE  | (ROW_ADR3  << 7) | NAND_ADR ), //send row adr3 to NAND
#ifndef NAND_BICS5
(INST_MOVE  | (ROW_ADR4  << 7) | NAND_ADR ), //send row adr4 to NAND
#endif
(INST_WRITE | (RCOL_END  << 7) | NAND_CMD ), //send change read column end(0xE0)" to NAND
(INST_WRITE | (WAIT_TCCS << 7) | NAND_WAIT), //need wait tCCS(275/300/400ns)
#ifdef DMY_READ
(INST_WRITE | (0x1       << 7) | NAND_READ), //dummy read
(INST_WRITE | (10        << 7) | NAND_WAIT), //need wait 10 cycle
#endif
(INST_WRITE | (0x0       << 7) | NAND_RDMA), //enable DMA read engine
(INST_WRITE | (0x0       << 7) | PROC_REG0), //set 0x0 to processor reg0
(INST_MOVE  | (DMA_STS   << 7) | PROC_REG1), //copy "dma status" to processor reg1
#ifdef NAND_BICS5
(INST_JUMP  | (JUMP_NEBK << 8) |   (11+JUMP_DRD)     ), //jump to "change read column cmd"
#else
(INST_JUMP  | (JUMP_NEBK << 8) |   (12+JUMP_DRD)     ), //jump to "change read column cmd"
#endif
#ifndef NAND_B47R
(INST_WRITE | (CEN_OFF   << 7) | NAND_CEN ), //disable CEn
//(INST_WRITE | (WAIT_TRPH << 7) | NAND_WAIT), //need wait tRPSTH(15/25ns)
#endif
(INST_FIN                                   )  //finish
},

//cache read end, cmd_ptr = 6'd5
//assign micro_code[5] =
{
(INST_MOVE  | (CEN_NUM   << 7) | NAND_CEN ), //enable CEn
(INST_WRITE | (RCAH_END  << 7) | NAND_CMD ), //send "cache read end(0x3F)" to NAND
(INST_WRITE | (RCMD_RSTS << 7) | SET_BUSY ), //set nand status as busy
(INST_FIN                                   )  //finish
},

//read aipr status command, cmd_ptr = 6'd6
//assign micro_code[6] =
{
(INST_MOVE  | (CEN_NUM   << 7) | NAND_CEN ), //enable CEn
(INST_WRITE | (AUTO_PL   << 7) | SET_PLANE), //init plane number, set auto plane cnt(0x10)
(INST_WRITE | (READ_ASTS << 7) | NAND_CMD ), //send read aipr status cmd(0x77) to NAND
(INST_MOVE  | (ROW_ADR1  << 7) | NAND_ADR ), //send row adr1 to NAND
(INST_MOVE  | (ROW_ADR2  << 7) | NAND_ADR ), //send row adr2 to NAND
(INST_MOVE  | (ROW_ADR3  << 7) | NAND_ADR ), //send row adr3 to NAND
#ifndef NAND_BICS5
(INST_MOVE  | (ROW_ADR4  << 7) | NAND_ADR ), //send row adr4 to NAND
#endif
#ifdef DMY_READ
(INST_WRITE | (0x1       << 7) | NAND_READ), //dummy read
(INST_WRITE | (10        << 7) | NAND_WAIT), //need wait 10 cycle
#endif
(INST_WRITE | (0x0       << 7) | NAND_READ), //read status
#ifdef PROC_TDLY
(INST_MOVE  | (NAND_RDT  << 7) | PROC_REG0), //dummy read for FPGA timing issue
#endif
(INST_MOVE  | (NAND_RDT  << 7) | STS_DATA ), //move NAND read data to status check reg
#ifndef NAND_B47R
(INST_WRITE | (CEN_OFF   << 7) | NAND_CEN ), //disable CEn
//(INST_WRITE | (WAIT_TRPH << 7) | NAND_WAIT), //need wait tRPSTH(15/25ns)
#endif
(INST_FIN                                   )  //finish
},

//aipr read command, cmd_ptr = 6'd7
//assign micro_code[7] =
{
(INST_MOVE  | (CEN_NUM   << 7) | NAND_CEN ), //enable CEn
(INST_WRITE | (AUTO_PL   << 7) | SET_PLANE), //init plane number, set auto plane cnt(0x10)
(INST_MOVE  | (AIPR_STS  << 7) | PROC_REG0), //copy "aipr status" to processor reg0
(INST_WRITE | (0x1       << 7) | PROC_REG1), //set "0x1" to processor reg1
(INST_JUMP  | (JUMP_EQFW << 8) |   7      ), //compare aipr status, if aipr set, jump to "read cmd"
(INST_WRITE | (READ_ESTS << 7) | NAND_CMD ), //send read enhance status cmd(0x78) to NAND
(INST_MOVE  | (ROW_ADR1  << 7) | NAND_ADR ), //send row adr1 to NAND
(INST_MOVE  | (ROW_ADR2  << 7) | NAND_ADR ), //send row adr2 to NAND
(INST_MOVE  | (ROW_ADR3  << 7) | NAND_ADR ), //send row adr3 to NAND
(INST_MOVE  | (ROW_ADR4  << 7) | NAND_ADR ), //send row adr4 to NAND
(INST_WRITE | (AIPR_ENTR << 7) | NAND_CMD ), //send aipr enable cmd(0x0B) to NAND
(INST_WRITE | (READ_PAGE << 7) | NAND_CMD ), //send read cmd(0x00) to NAND
(INST_WRITE | (0x0       << 7) | NAND_ADR ), //send column adr1 to NAND
(INST_WRITE | (0x0       << 7) | NAND_ADR ), //send column adr2 to NAND
(INST_MOVE  | (ROW_ADR1  << 7) | NAND_ADR ), //send row adr1 to NAND
(INST_MOVE  | (ROW_ADR2  << 7) | NAND_ADR ), //send row adr2 to NAND
(INST_MOVE  | (ROW_ADR3  << 7) | NAND_ADR ), //send row adr3 to NAND
(INST_MOVE  | (ROW_ADR4  << 7) | NAND_ADR ), //send row adr4 to NAND
//(INST_MOVE  | (ECTI_STS  << 7) | PROC_REG0), //copy "cache status" to processor reg0
//(INST_WRITE | (RCAH_SET  << 7) | PROC_REG1), //set "cache read set" to processor reg1
//(INST_JUMP  | (JUMP_EQFW << 8) |   3      ), //compare cache status, if cache read set, jump to "cache read cmd"
(INST_WRITE | (READ_END  << 7) | NAND_CMD ), //send read end(0x30) to NAND
//(INST_JUMP  | (JUMP_NCFW << 8) |   2      ), //jump to "set nand status"
//(INST_WRITE | (RCAH_CMD  << 7) | NAND_CMD ), //send cache read(0x31) to NAND
(INST_WRITE | (AIPR_RSTS << 7) | SET_BUSY ), //set nand status as busy
(INST_FIN                                   )  //finish
} };
